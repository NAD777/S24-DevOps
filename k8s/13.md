# Lab 13

## Task 2

Output of `kubectl get po,sts,svc,pvc`:
```bash
NAME               READY   STATUS    RESTARTS   AGE
pod/app-python-0   1/1     Running   0          103s
pod/app-python-1   1/1     Running   0          89s

NAME                          READY   AGE
statefulset.apps/app-python   2/2     5m11s

NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/app-python   NodePort    10.101.179.108   <none>        5001:31494/TCP   5m11s
service/kubernetes   ClusterIP   10.96.0.1        <none>        443/TCP          6m4s

NAME                                     STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/vol-app-python-0   Bound    pvc-2d8816ff-9122-4685-9d7e-d22f94a4c41a   2Gi        RWO            standard       5m11s
persistentvolumeclaim/vol-app-python-1   Bound    pvc-be529cc7-e4f2-4033-ba49-32797f5dff6c   2Gi        RWO            standard       89s
```

Output of `kubectl exec pod/app-python-0 -- cat vol/visits`:
```bash
8
```

Output of `kubectl exec pod/app-python-1 -- cat vol/visits`:
```bash
14
```

Balancing happens between pods. The different content of the visits file in each pod (8 in app-python-0 and 14 in app-python-1) highlights how each instance of application maintains its own state. These values indicate that the pods are not sharing this file and each one is incrementing its counter based on the visits it individually handles. This is a key feature of using StatefulSets, as opposed to Deployments where state is not preserved individually across replicas.

## Ordering Guarantee and Parallel Operations

In the context of this application, there is no requirement for ordering guarantees, as each pod operates independently from the others. This characteristic allows for the parallel initiation of multiple pods without dependency constraints.

## Understanding Kinds of Update Strategies

- **RollingUpdate**: This is the default strategy for StatefulSets. Under this strategy, updates proceed sequentially from the highest numbered pod to the lowest, ensuring that no more than one pod is taken down at a time. This minimizes downtime but ensures that the update is gradual and controlled.
- **OnDelete**: When this strategy is used, Kubernetes will not automatically update the pods when the StatefulSet's configuration is altered. Instead, each pod must be manually deleted, after which Kubernetes recreates the pod with the new configuration. This strategy gives the developer or administrator more control over the update process but requires more manual intervention.


## Describing Differences

- **Control and Automation**: Compare the level of control and automation each strategy offers. RollingUpdate automates the update process and ensures service availability but at a slower pace. OnDelete, on the other hand, provides more control to the operator at the cost of increased manual effort and potential service downtime.
- **Use Cases**: Discuss the typical use cases for each strategy. For instance, RollingUpdate might be more suitable for applications where continuous availability is crucial, whereas OnDelete could be preferred in environments where precise control over the update process is needed.